# `VisualObjectEngine` API Documentation

## 1. Overview

The `VisualObjectEngine` facilitates the declarative creation of complex, MIDI-driven visual objects within a Synthesizer. It allows Synthesizers to define rules for generating visual objects based on MIDI input, time, and custom synthesizer properties using a declarative, chainable API. This enables complex visual behaviors like nested generation and intricate property mapping with minimal boilerplate code.

The engine relies on the Synthesizer instance being immutable; when synthesizer properties change, a new Synthesizer instance (with its own engine configuration) is created. Mapper and generator functions defined within the Synthesizer's scope capture the correct `this.properties` via closure.

## 2. `VisualObjectEngine` Class

The main class responsible for storing definitions and executing the generation logic.

*   **`constructor()`**
    *   Creates a new, empty engine instance. Typically stored as a member variable within a `Synthesizer` subclass.

*   **`defineObject(initialType: string): ObjectDefinition`**
    *   Starts a new object definition chain. This chain describes the complete generative process triggered by a MIDI note that matches its optional `.when()` condition.
    *   `initialType`: The default `VisualObject.type` (e.g., `'cube'`, `'sphere'`) for the first level of instances generated in this chain. This can be overridden for specific levels using `.setType()`.
    *   Returns an `ObjectDefinition` instance for further chaining. Multiple `defineObject` chains can be added to the engine.

*   **`getObjectsAtTime(time: number, midiBlocks: MIDIBlock[], bpm: number): VisualObject[]`**
    *   The primary execution method called by the `Synthesizer`.
    *   Processes all defined object chains against the provided MIDI data and context for the current frame.
    *   Filters active MIDI notes based on `time`.
    *   For each active note matching a chain's `.when()` condition, it executes the chain's generative logic (processing `.forEachInstance` calls and executing the stored mapper/generator functions).
    *   Mapper/generator functions access the Synthesizer's properties via their original closure.
    *   Aggregates and returns the final list of `VisualObject` instances to be rendered.

## 3. `ObjectDefinition` Methods (Chainable)

Methods called on the object returned by `defineObject` or subsequent chaining methods. Modifiers apply configuration to the instances generated by the **immediately preceding** `.forEachInstance()` call (or to Level 1 instances if called before the first `.forEachInstance()`). Mapper and generator functions defined here should use `this.properties` or `this.getPropertyValue` (from the Synthesizer scope) to access synthesizer parameters.

*   **`.when(conditionFn: (noteCtx: NoteContext) => boolean): ObjectDefinition`**
    *   *Optional.* Specifies a condition based on the initial MIDI note for this chain to execute.
    *   `noteCtx`: Contains `{ note: MIDINote }`. (Access synthProps via `this` in the function body).

*   **`.forEachInstance(generatorFn: (parentContext: MappingContext) => InstanceData[]): ObjectDefinition`**
    *   Defines how to generate multiple instances at the current nesting level, based on the parent's context. Implicitly defines a new nesting level.
    *   `generatorFn`: Receives `parentContext`, returns an array of `InstanceData` objects.
    *   Subsequent modifiers apply to the instances generated by *this* call.

*   **`.withPosition(mapperFn: (ctx: MappingContext) => [number, number, number]): ObjectDefinition`**
    *   Defines the `position` calculation (`[x, y, z]`).
    *   `mapperFn`: Receives `MappingContext`, returns position array.

*   **`.withScale(mapperFn: (ctx: MappingContext) => [number, number, number] | number): ObjectDefinition`**
    *   Defines the `scale` calculation (uniform number or `[sx, sy, sz]`).

*   **`.withRotation(mapperFn: (ctx: MappingContext) => [number, number, number]): ObjectDefinition`**
    *   Defines the `rotation` calculation (Euler angles `[rx, ry, rz]`).

*   **`.withColor(mapperFn: (ctx: MappingContext) => string): ObjectDefinition`**
    *   Defines the `color` calculation (e.g., hex, hsl).

*   **`.withOpacity(mapperFn: (ctx: MappingContext) => number): ObjectDefinition`**
    *   Defines the `opacity` calculation (0-1).

*   **`.setType(type: string): ObjectDefinition`**
    *   Sets the `VisualObject.type` for instances at the current level.

*   **`.applyADSR(config: { attack: number, decay: number, sustain: number, release: number } | ((noteCtx: NoteContext) => { attack: number, decay: number, sustain: number, release: number })): ObjectDefinition`**
    *   Applies an ADSR envelope to instances at the current level.
    *   `config`: Can be a static config object *or* a function receiving `noteCtx` that returns a config object (allowing ADSR parameters to be derived from `this.properties`).
    *   Calculated `adsrAmplitude` and `adsrPhase` are added to the `MappingContext`.

## 4. `MappingContext` Object

Passed to `mapperFn` and `generatorFn` callbacks. Contains data specific to the instance being generated/configured.

*   `note: MIDINote`: Original triggering MIDI note.
*   `time: number`: Current global time (beats).
*   `bpm: number`: Current beats per minute.
*   `timeSinceNoteStart: number`: Time elapsed (seconds) since `note` started.
*   `noteProgressPercent: number`: Progress (0-1) through `note`'s nominal duration.
*   `noteDurationSeconds: number`: `note`'s duration (seconds).
*   `level: number`: Current nesting depth (1 = initial).
*   `instanceData: any`: Data for this instance from its `.forEachInstance` generator.
*   `parentContext?: MappingContext`: Context of the parent instance (undefined for level 1). Access parent state via `parentContext.calculatedProperties`, etc.
*   `adsrAmplitude?: number`: Current ADSR amplitude (0-1) for this level.
*   `adsrPhase?: 'attack' | 'decay' | 'sustain' | 'release' | 'idle'`: Current ADSR phase for this level.
*   `calculatedProperties?: VisualObjectProperties`: Read-only view of properties calculated so far for the *current* instance (primarily for parent context access).
*   **(Note:** `synthProps` are *not* in the context; access them via closure using `this.properties` or `this.getPropertyValue` within the mapper/generator function definition).

## 5. `MappingUtils` Helper Class (Static Methods)

Provides utility functions for use within mappers and generators.

*   `mapValue(value, inMin, inMax, outMin, outMax, clamp=true)`
*   `mapPitchToRange(pitch, outMin, outMax, pitchMin=0, pitchMax=127)`
*   `mapPitchToHSL(pitch, saturation, lightness, hueStart=0, hueEnd=360)`
*   `mapValueToHSL(value, saturation, lightness, inMin, inMax, hueStart=0, hueEnd=360)`
*   *(Potential additions: easing, noise, gradients, etc.)*

## 6. Example Snippet

```typescript
// --- Inside Synthesizer Constructor ---
this.engine = new VisualObjectEngine();
const MUtils = MappingUtils;

this.engine.defineObject('cube')
    .when(noteCtx => noteCtx.note.velocity > 50)
    .applyADSR(noteCtx => ({ // Get ADSR params from synth properties
        attack: this.getPropertyValue('attack') ?? 0.1,
        decay: this.getPropertyValue('decay') ?? 0.5,
        sustain: this.getPropertyValue('sustain') ?? 0.7,
        release: this.getPropertyValue('release') ?? 1.0,
    }))
    .forEachInstance(noteCtx => [/* level 1 instance data */])
    .withPosition(ctx => { // Access synth props via `this`
        const baseHeight = this.getPropertyValue('height') ?? 0;
        return [ ctx.instanceData.x, baseHeight, ctx.instanceData.z ];
    })
    .withScale(ctx => /* use ctx.adsrAmplitude */)
    .setType('sphere')
    .applyADSR(ADSR_B) // Can still use static config
    .forEachInstance(parentCtx => [/* level 2 instance data */])
    .withPosition(ctx => [ /* use ctx.adsrAmplitude from ADSR_B */ ])
    .withColor(ctx => MUtils.mapPitchToHSL(ctx.note.pitch, 80, 70));

// --- Inside Synthesizer.getObjectsAtTime(time, midiBlocks, bpm) ---
return this.engine.getObjectsAtTime(time, midiBlocks, bpm);
``` 